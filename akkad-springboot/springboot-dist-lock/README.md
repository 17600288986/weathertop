
<!-- TOC -->

- [1. 概述](#1-概述)
- [2. 特点](#2-特点)
- [3. 实现方式](#3-实现方式)
- [4. 数据库实现](#4-数据库实现)
    - [4.1. 前提](#41-前提)
        - [4.1.1. 乐观锁](#411-乐观锁)
        - [4.1.2. 悲观锁](#412-悲观锁)
    - [4.2. 乐观锁实现](#42-乐观锁实现)
    - [4.3. 悲观锁实现](#43-悲观锁实现)
        - [4.3.1. 方案1_for update](#431-方案1_for-update)
        - [4.3.2. 方案2_唯一性约束](#432-方案2_唯一性约束)
        - [4.3.3. 方案3_查询并占有](#433-方案3_查询并占有)
        - [4.3.4. 附 表结构](#434-附-表结构)
    - [4.4. 总结](#44-总结)
        - [4.4.1. 缺点](#441-缺点)
- [5. Redis实现](#5-redis实现)

<!-- /TOC -->

# 1. 概述

在高可用大型互联网业务系统都是高度复杂且都是分布式架构，这样的确提高了可用性和和稳定性，但也带来也多节点在执行过程中相互干扰，这在针对同一资源的处理过程中产生数据不一致。如果能保证在同一时刻该资源只能被一个应用处理，而不能并发处理。由此我们引入一种分布式协调机制来调度，而这种分布式协调机制的核心我们称之为分布式锁。

![20191115223356.png](https://i.loli.net/2019/11/15/C58bJhagzF1wROp.png)

+ 成员变量 V 存在 JVM_1、JVM_2、JVM_3 三个 JVM 内存中
+ 成员变量 V 同时都会在JVM分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的
+ 不是同时发过来，三个请求分别操作三个不同 JVM 内存区域的数据，变量 V 之间不存在共享，也不具有可见性，处理的结果也是不对的

注：该成员变量**V**是一个有状态的对象，主要体现在一个类的成员变量。

# 2. 特点

- 在分布式系统环境下，同一个方法在同一时间只能被一个机器的同一个线程执行；
- 高可用的获取锁与释放锁；
- 高性能的获取锁与释放锁；
- 具备可重入特性；
- 具备锁的自我失效机制，防止死锁；
- 满足非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。

# 3. 实现方式

根据分布式的CAP理论我们了解“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”

所以我们在系统设计之初就分析调研，根据分析调研结果对这三者做取舍。

借鉴在主流互联网的经验，都牺牲强一致性来换取系统的高可用性，系统的“一致性”只保证“最终一致性”，这个最终时间需要在可控可接受的范围内。很多场景下，我们为了保证最终一致性，都会做很多技术方案来支持，比如分布式事务、分布式锁。

在分布式锁的技术实现上，主流认可有三种实现方式，从复杂度来看，由难至易依次增加：
> 基于数据库实现分布式锁；

> 基于缓存（Redis/Memcached等）实现分布式锁；

> 基于Zookeeper实现分布式锁；

无论哪一种方式，都不可能完美，需要根据实际业务场景做出选择。

# 4. 数据库实现

## 4.1. 前提

在了解数据库实现分布式锁的之前，我们首了解**乐观锁（Optimistic Lock）**和**悲观锁（Pessimistic Lock）**。

### 4.1.1. 乐观锁

每次去取数据的时候都会认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现；乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

### 4.1.2. 悲观锁

每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要block阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，它对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。在 Java中，synchronized的思想也是悲观锁。

**乐观锁、悲观锁**两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。本质上，数据库的乐观锁做法和悲观锁做法主要就是解决下面假设的场景，避免丢失更新问题：

## 4.2. 乐观锁实现

从上面的前提概要我们知道，乐观锁机制其实就是在数据库表中引入一个版本号（version）字段来实现的。

当我们要从数据库中读取数据的时候，同时把这个version字段也读出来，如果要对读出来的数据进行修改写回数据库时，则需要将version加1，同时将新的数据与新的version更新到数据表中，且必须在更新的时候同时检查目前数据库里version值是不是之前的那个version，如果是，则正常更新。如果不是，则更新失败，说明在这个过程中有其它的进程去更新过数据了。

![20191115230824.png](https://i.loli.net/2019/11/15/5oOsY7n8GQURB2r.png)

假定同一账号下，小明和小明媳妇同时取银行进行取款操作，账户余额200￥，小明取款100￥，小明媳妇取款150￥。

- 没有锁机制的场景下，可能会出现账户同时被扣款150￥和100￥，导致账户余额出现负数情况，这样的话银行可能混不下去。

- 如果我们用到锁机制，小明和小明媳妇都在取款时候，除看到余额的操作，还在后台事务中读取版本号version=1，不论小明和小明媳妇先成功执行取款操作，都会将版本号version+1，即version=2，没有成功执行的那一方再去操作时候读取出来的version是2，那么就会触发重新获取余额。

乐观锁关键点：

- 锁服务要有递增的版本号version

- 每次更新数据都要先判断版本号对不对，然后再写入新的版本号

## 4.3. 悲观锁实现

### 4.3.1. 方案1_for update

Oracle、Mysql中是基于<font color=red>**for update**</font>来实现加锁的。在MYSQL中需要注意的是，在InnoDB中只有字段加了索引的，才会是行级锁，否者是表级锁，所以一定要对where的条件字段加索引。

当这条记录加上排它锁之后，其它线程是无法操作这条记录的。

### 4.3.2. 方案2_唯一性约束

对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功。

~~~

INSERT INTO method_lock (method_name, desc) VALUES ('methodName', 'methodName');
~~~

### 4.3.3. 方案3_查询并占有

先获取锁的信息：

~~~
select id, method_name, state,version from method_lock where state=1 and method_name='methodName';
~~~

再占有

~~~

update t_resoure set state=2, version=2, update_time=now() where method_name='methodName' and state=1 and version=2;

~~~

如果没有更新影响到一行数据，则说明这个资源已经被别人占位了。

### 4.3.4. 附 表结构

~~~

DROP TABLE IF EXISTS method_lock;

CREATE TABLE method_lock (
lck_id INT(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
method_name VARCHAR(64) NOT NULL COMMENT '锁定的方法名',
state TINYINT NOT NULL COMMENT '1:未分配；2：已分配',
update_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
ver INT NOT NULL COMMENT '版本号',
PRIMARY KEY (lck_id),
UNIQUE KEY uidx_method_name (method_name) USING BTREE
) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
~~~

## 4.4. 总结

### 4.4.1. 缺点

> 这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。

> 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。

> 这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。

> 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。

配置实现细节

- 数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。

- 没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。

- 非阻塞的？搞一个while循环，直到insert成功再返回成功。

- 非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。

# 5. Redis实现

基于Redis实现的锁机制，主要是依赖redis自身的原子操作，因为redis是单线程。要求redis版本大于2.6.12。
